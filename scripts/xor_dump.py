#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Universal Binary Analyzer

Functionality:
This script automatically analyzes ARM64 ELF and Mach-O (including Fat Mach-O) files
to locate and extract an encryption key table protected by a specific pattern.

Workflow:
1. Locate a known anchor string ("MetaData") in the read-only data section.
2. Find the unique reference to this string in the code section to locate the target function.
3. Search downward from the reference point for a do-while loop (identified by a backward B.NE branch).
4. Analyze the instruction logic chain (AND -> LDRB) inside the loop to dynamically determine:
    - The size of the key table.
    - The register used for indexing.
    - The register holding the key table base address.
5. Backtrack from the loop entry to find the ADRP+ADD pair that assigns the base address, 
   calculating the actual virtual address of the key table.
6. Extract the key table data and format it as a C++ array.

Dependencies:
- lief (pip install lief)
- capstone (pip install capstone)

Generated by Gemini 2.5 Pro
"""

import sys
from pathlib import Path
from importlib.util import find_spec
from typing import Optional, Tuple

if find_spec('lief') is None or find_spec('capstone') is None:
    print("lief / capstone is not installed. Please install it with `pip install lief capstone`")
    sys.exit(1)

import lief
from capstone import Cs, CsInsn, CS_ARCH_ARM64, CS_MODE_ARM
from capstone.arm64_const import ARM64_REG_SP

# --- Global Configuration ---
TARGET_STRING = b'Metadata\0'
TARGET_BRANCH_INSTRUCTION = 'b.ne'
FUNC_PROLOGUE_SEARCH_WINDOW = 512 # Max bytes to search upwards for function prologue

class FileParser:
    binary: lief.Binary

    """
    An abstract file parser wrapping LIEF functionality to provide a unified interface
    for ELF and Mach-O (including Fat) files.
    """
    def __init__(self, file_path: str):
        parsed_file = lief.parse(file_path)
        if not parsed_file:
            raise ValueError(f"Unable to parse file: {file_path}")
        
        # Handle FatBinary files which may contain multiple architectures
        if isinstance(parsed_file, lief.MachO.FatBinary):
            print("[*] Fat Binary detected, searching for ARM64 slice...")
            for bin_slice in parsed_file:
                assert isinstance(bin_slice, lief.MachO.Binary), "Type hint assertion failed."
                if bin_slice.header.cpu_type == lief.MachO.Header.CPU_TYPE.ARM64:
                    self.binary = bin_slice
                    print("[+] ARM64 slice selected successfully!")
                    break
            if not self.binary:
                raise ValueError("No ARM64 slice found in Fat Binary.")
        elif isinstance(parsed_file, lief.MachO.Binary):
            self.binary = parsed_file
        elif isinstance(parsed_file, lief.ELF.Binary):
            self.binary = parsed_file
        else:
            raise ValueError(f"Unsupported binary format: {type(parsed_file)}")

        self.file_type = "Mach-O" if isinstance(self.binary, lief.MachO.Binary) else "ELF"
        print(f"[*] Selected binary type: {self.file_type}")

        if not self._is_aarch64():
            raise TypeError("The selected binary is not AArch64 (ARM64) architecture.")

    def _is_aarch64(self) -> bool:
        if isinstance(self.binary, lief.MachO.Binary):
            return self.binary.header.cpu_type == lief.MachO.Header.CPU_TYPE.ARM64
        elif isinstance(self.binary, lief.ELF.Binary):
            return self.binary.header.machine_type == lief.ELF.ARCH.AARCH64
        return False

    def get_section(self, name: str) -> Optional[lief.Section]:
        assert isinstance(self.binary, (lief.MachO.Binary, lief.ELF.Binary)), "Unsupported binary type."
        return self.binary.get_section(name)

    def read_from_va(self, va: int, size: int) -> Optional[bytes]:
        try:
            return bytes(self.binary.get_content_from_virtual_address(va, size))
        except Exception:
            return None

class BinaryAnalyzer:
    """
    Main analyzer class encapsulating all reverse engineering logic steps.
    """
    def __init__(self, parser: FileParser):
        self.parser = parser
        self.md = Cs(CS_ARCH_ARM64, CS_MODE_ARM)
        self.md.detail = True
        self.key_table = None

    def run(self):
        """Executes the full analysis workflow"""
        # Step 1: Find anchor string
        string_addr = self._find_target_string()
        if not string_addr: 
            return

        # Step 2: Locate string reference and code section
        result = self._find_string_reference(string_addr)
        if not result: 
            return
        text_section, ref_addr = result

        # Step 3: Estimate function start
        func_start_addr = self._find_function_start(text_section, ref_addr)
        
        # Step 4: Locate do-while loop
        b_ne_instruction = self._find_loop(text_section, ref_addr)
        if not b_ne_instruction: 
            return

        # Step 5 & 6: Analyze loop and extract key
        self._find_and_extract_key_table(text_section, b_ne_instruction, func_start_addr)
        return self.key_table

    def _find_target_string(self) -> Optional[int]:
        """Searches for the target string in the appropriate read-only data sections."""
        section_names = {
            "Mach-O": ["__cstring", "__const"], # Primary and fallback sections
            "ELF":     [".rodata"]
        }[self.parser.file_type]
        
        print(f"[1/6] Searching for string in sections: {', '.join(section_names)}...")
        
        for sec_name in section_names:
            target_sec = self.parser.get_section(sec_name)
            if not target_sec: 
                continue
            
            data = bytes(target_sec.content)
            offset = data.find(TARGET_STRING)
            if offset != -1:
                string_addr = target_sec.virtual_address + offset
                print(f"[+] Success! String found at 0x{string_addr:x} (in {sec_name} section)")
                return string_addr
                
        print(f"[-] Error: Could not find string '{TARGET_STRING.decode()}'.")
        return None

    def _find_string_reference(self, string_addr: int) -> Optional[Tuple[lief.Section, int]]:
        """
        Searches for a reference to the string address within the code section.
        Logic: Modern compilers often use ADRP+ADD pairs for position-independent addressing.
        - ADRP Xd, <page_addr>: Loads the base page address into register Xd.
        - ADD  Xd, Xd, #<offset>: Adds the page offset to get the full address.
        """
        print(f"[2/6] Searching for reference to 0x{string_addr:x} in code section...")
        text_sec_name = "__text" if self.parser.file_type == "Mach-O" else ".text"
        text_sec = self.parser.get_section(text_sec_name)
        if not text_sec:
            print(f"[-] Error: Could not find code section '{text_sec_name}'")
            return None

        code, base_addr = bytes(text_sec.content), text_sec.virtual_address
        last_adrp_for_reg = {}
        for insn in self.md.disasm(code, base_addr):
            if insn.mnemonic == 'adrp':
                last_adrp_for_reg[insn.operands[0].reg] = insn
            elif insn.mnemonic == 'add':
                if len(insn.operands) < 3: 
                    continue
                dest_reg, src_reg = insn.operands[0].reg, insn.operands[1].reg
                if dest_reg == src_reg and src_reg in last_adrp_for_reg:
                    adrp_insn = last_adrp_for_reg[src_reg]
                    calculated_addr = adrp_insn.operands[1].imm + insn.operands[2].imm
                    if calculated_addr == string_addr:
                        print(f"[+] Success! String reference found at 0x{adrp_insn.address:x}")
                        return text_sec, adrp_insn.address
        
        print("[-] Error: Could not find reference to the string.")
        return None

    def _find_function_start(self, text_sec: lief.Section, ref_addr: int) -> int:
        """
        Backtracks from the reference point to estimate the function start via the prologue.
        Logic: ARM64 functions typically start with `SUB SP, SP, #imm` to allocate stack space.
        """
        print(f"[3/6] Backtracking from {hex(ref_addr)} to estimate function start...")
        base_addr, code = text_sec.virtual_address, bytes(text_sec.content)
        search_end_offset = ref_addr - base_addr
        search_start_offset = max(0, search_end_offset - FUNC_PROLOGUE_SEARCH_WINDOW)
        
        code_to_scan = code[search_start_offset:search_end_offset]
        instructions = list(reversed(list(self.md.disasm(code_to_scan, base_addr + search_start_offset))))
        
        for insn in instructions:
            if insn.mnemonic == 'sub' and len(insn.operands) == 3 and \
               insn.operands[0].reg == insn.operands[1].reg == ARM64_REG_SP:
                print(f"[+] Found probable prologue `SUB SP, SP, ...` at 0x{insn.address:x}")
                return insn.address
        
        print("[!] Warning: Could not find clear prologue; using reference point as start.")
        return ref_addr

    def _find_loop(self, text_sec: lief.Section, ref_addr: int) -> Optional[CsInsn]:
        """
        Searches downward for the B.NE instruction of the do-while loop.
        Logic: A do-while loop is identified by a conditional backward jump at the end.
        """
        print(f"[4/6] Searching downward from {hex(ref_addr)} for the loop...")
        code, base_addr = bytes(text_sec.content), text_sec.virtual_address
        offset = ref_addr - base_addr
        for insn in self.md.disasm(code[offset:], ref_addr):
            if insn.mnemonic == TARGET_BRANCH_INSTRUCTION and insn.operands[0].imm < insn.address:
                print(f"[+] Success! Located loop jump at 0x{insn.address:x}")
                return insn
        print("[-] Error: Could not find 'b.ne' jump for do-while structure.")
        return None

    def _find_and_extract_key_table(self, text_sec: lief.Section, b_ne_insn: CsInsn, func_start_addr: int):
        """
        Analyzes the loop body to locate the base register, backtracks to find assignment, 
        and extracts the key table.
        """
        print("[5/6] Analyzing loop body to extract key...")
        loop_start_addr, loop_end_addr = b_ne_insn.operands[0].imm, b_ne_insn.address
        code, base_addr = bytes(text_sec.content), text_sec.virtual_address
        
        loop_code = code[loop_start_addr - base_addr : loop_end_addr - base_addr + 4]
        loop_instructions = list(self.md.disasm(loop_code, loop_start_addr))

        # Logic Chain 1: Find `AND X_idx, X_iter, #mask` instruction.
        index_reg, key_size = None, None
        for insn in loop_instructions:
            if insn.mnemonic == 'and' and len(insn.operands) == 3 and insn.operands[2].type == 2:
                index_reg, mask = insn.operands[0].reg, insn.operands[2].imm
                key_size = mask + 1
                print(f"[+] -> Found 'AND' instruction, index register: {self.md.reg_name(index_reg)}, size: {key_size}")
                break
        if not index_reg: 
            print("[-] Error: 'AND' instruction not found.")
            return
        if key_size is None:
            print("[-] Error: Unable to determine key table size.")
            return

        # Logic Chain 2: Use `X_idx` to find `LDRB W_val, [X_base, X_idx]` instruction.
        base_reg = None
        for insn in loop_instructions:
            if insn.mnemonic == 'ldrb' and insn.operands[1].mem.index == index_reg:
                base_reg = insn.operands[1].mem.base
                print(f"[+] -> Found 'LDRB' instruction, base register: {self.md.reg_name(base_reg)}")
                break
        if not base_reg: 
            print("[-] Error: 'LDRB' instruction not found.")
            return

        # Logic Chain 3: Backtrack from loop entry to find ADRP+ADD pair for `X_base`.
        search_end_addr = loop_start_addr
        search_start_addr = max(func_start_addr, search_end_addr - 256)
        code_to_scan = code[search_start_addr - base_addr : search_end_addr - base_addr]
        rev_insns = list(reversed(list(self.md.disasm(code_to_scan, search_start_addr))))
        
        add_insn, adrp_insn = None, None
        for insn in rev_insns:
            if not add_insn and insn.mnemonic == 'add' and insn.operands[0].reg == base_reg: 
                add_insn = insn
            if add_insn and not adrp_insn and insn.mnemonic == 'adrp' and insn.operands[0].reg == base_reg: 
                adrp_insn = insn
                break
        if not (adrp_insn and add_insn): 
            print(f"[-] Error: Could not find ADRP+ADD pair for {self.md.reg_name(base_reg)}.")
            return

        # Logic Chain 4: Calculate address and extract key data.
        key_table_addr = adrp_insn.operands[1].imm + add_insn.operands[2].imm
        print(f"[+] -> Calculated key table address: 0x{key_table_addr:x}")

        print("[6/6] Extracting and formatting key table...")
        key_data = self.parser.read_from_va(key_table_addr, key_size)
        if not key_data:
            print(f"[-] Error: Failed to read key data from 0x{key_table_addr:x}.")
            return
        
        self.format_as_cpp_array(key_data)
        print("\n[*] Key table extracted successfully!")
        self.key_table = key_data

    @staticmethod
    def format_as_cpp_array(data: bytes, table_name: str = "key_table"):
        """Formats byte data as a C++ style array."""
        print(f"\n// Extracted key table ({len(data)} bytes)")
        print(f"unsigned char {table_name}[{len(data)}] = {{")
        line = "    "
        for i, byte in enumerate(data):
            line += f"0x{byte:02x}, "
            if (i + 1) % 16 == 0:
                print(line)
                line = "    "
        if line.strip(): 
            print(line.rstrip(" ,"))
        print("};")

def decrypt_global_metadata(bin_data: bytes, key_table: bytes) -> bytes:
    result = bytearray(bin_data)
    for i in range(len(result)):
        result[i] ^= key_table[i % len(key_table)]
    return bytes(result)

def main():
    """Main program entry point"""
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print(f"Usage: python3 {sys.argv[0]} <elf_or_macho_file_path> [global_metadata_file_path]")
        sys.exit(1)

    file_path = sys.argv[1]
    global_metadata_path = sys.argv[2] if len(sys.argv) == 3 else None
    
    try:
        parser = FileParser(file_path)
        analyzer = BinaryAnalyzer(parser)
        key_table = analyzer.run()

    except (ValueError, TypeError) as e:
        print(f"\n[-] File parsing or initialization error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n[-] An unknown serious error occurred: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

    if global_metadata_path and key_table is not None:
        print(f'[*] Processing global metadata file: {global_metadata_path}')
        bin_data = Path(global_metadata_path).read_bytes()
        print(f"[*] Metadata decryption XOR table: {key_table.hex()} ")
        decrypted = decrypt_global_metadata(bin_data, key_table)
        
        # Verify if the decrypted header matches expectations (0x FAB11BAF)
        if decrypted[:4] != b'\xaf\x1b\xb1\xfa':
            print("[-] Error: Decrypted header does not match expected signature. Decryption failed.")
            sys.exit(1)

        output_path = Path(global_metadata_path).parent / "global-metadata.dat.decrypted"
        xor_key = Path(global_metadata_path).parent / "xor_key.txt"

        output_path.write_bytes(decrypted)
        xor_key.write_text(key_table.hex(), encoding="utf8")
        print(f"[+] Global-metadata.dat decrypted successfully! Output: {output_path}")
    elif global_metadata_path and key_table is None:
        print("[-] Key table extraction failed; cannot decrypt.")

if __name__ == '__main__':
    main()
